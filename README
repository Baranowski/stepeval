Contact haskell at benmachine dot co dot uk or via IRC benmachine on Freenode

BUILD NOTES:

On base-4, it requires very little to drop the extensible-exceptions
dependency, just drop the .Extensible from the imports.

TODO:

Parethise doesn't respect any fixities it encounters (and uses the prelude
ones instead, which should be unnecessary)

The testsuite has no means for requiring that evaluation stop at a given
point.

In function application results aren't always shared as much as they should
be. Basically evaluation is often non-strict instead of lazy, as in the
classic example let double x = x + x in double (double 10)

A detached larger environment so that an actually decent library can be
ticking away behind the scenes. This includes better support for primitive
operations like arithmetic.

Polymorphism?

Everywhere in the program I have emphasised correctness and simplicity of
code over performance. In a lot of small ways and a few big ones the
efficiency of the algorithms involved is much poorer than it needs to be.

Pattern matching can see deep into bindings, which may make how it found
a match non-obvious. For example:
let x = 1 : x in
  case x of
      _ : _ : _ : _ : _ -> True
matches immediately.

FIXME:

Nested let-scopes aren't properly supported.

If you use an external definitions file, the evaluator doesn't know that
those definitions can't be changed, so pattern bindings that require
evaluation may go wrong. This isn't really a big deal though because such
files are intended mainly for functions, which don't have this problem.

